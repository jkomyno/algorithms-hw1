\section{Conclusioni}
\label{cap:conclusions}

Abbiamo già ampiamente discusso gli algoritmi, tempi di esecuzione, scelte implementative e ``furberie'' per rendere il codice più
efficiente. In particolare alla sezione \ref{cap:performance-analysis} è possibile trovare le risposte alle due principali domande
dell'homework e l'analisi delle performance, mentre in \ref{cap:benchmark-process} è stato descritto il processo di benchmark adottato. 
Nelle sezioni \ref{cap:code-structure}, \ref{cap:implementation-choices} e \ref{cap:algorithms} è possibile trovare invece
i dettagli tecnici quali struttura, scelte implementative e codice degli algoritmi. La sezione \ref{cap:tests} descrive il processo
di testing svolto, mentre la sezione \ref{cap:extensions-and-originalities} descrive le estensioni esplorate per rendere gli 
algoritmi più efficienti.

Questo homework ci ha permesso in primo luogo di capire a fondo le logiche e gli algoritmi per il calcolo del Minimum Spaning Tree dal
punto di vista intuitivo e teorico. In secondo luogo, dato l'aspetto fortemente pratico dell'esercizio, ci ha permesso di confrontarci
e sperimentare diverse tecniche e soluzioni di implementazione diverse e originali, ricercando anche con fantasia la nuova 
implementazione che potesse essere più efficiente delle precedenti, stando però sempre attenti a garantire la correttezza dei risultati.

Il problema, oltre che agli algoritmi del calcolo dell'MST quali KruskalNaive, KruskalUnionFind e PrimBinaryHeap, ci ha permesso di 
sviluppare anche un buon numero di strutture dati da zero e algoritmi ``collaterali'' da utilizzare in combinazione con i principali.
Si veda ad esempio la struttura dati per la rappresentazione del grafo, componente fondamentale e utilizzata da tutti gli algoritmi. 
Questa componente se non implementata a dovere, avrebbe inficiato le performance di tutti gli algoritmi, penalizzando così i nostri
risultati.

Altri due aspetti fondamentali che abbiamo dovuto affrontare sono stati il benchmarking degli algoritmi, facendo attenzione a svolgere
le misurazioni in modo più scientifico possibile e il testing degli algoritmi per garantire la correttezza della soluzione di modo da
non vanificare gli sforzi effettuati per rendere efficienti gli algoritmi.

Altro punto importante è stato il saper lavorare in gruppo: un progetto tutto sommato non troppo piccolo come questo ci ha
fatto capire l'importanza del saper cooperare, condividere e sviluppare idee, essere aperti ai confronti e ai suggerimenti.

\vspace{1em}
In conclusione, per noi l'esperienza è stata molto positiva e oltre a capire diversi aspetti del mondo gli algoritmi e delle strutture
dati ci ha permesso di sviluppare skill sicuramente utili per un informatico.